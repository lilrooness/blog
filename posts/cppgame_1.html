<html>

<head>

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css" />
</head>

<title>JOY</title>

<body>

    <a class="home_link" href="../index.html">
        <h1 class="title">Joe It Yourself</h1>
    </a>
    <h2 class="heading">Building Reusable Components for Summoners Table in C++</h2>


    <div class="post">
        <p>

            NOTE: (read <a href="https://learnopengl.com/Getting-started/Hello-Triangle">this</a> if you want to know
            how
            OpenGL
            works, It's not really
            a requirement for understanding what I
            talk about here, but it will enable you to form your own
            oppinions about what I'm doing)<br /><br /><br />
            Being furloughed, I decided to start a new game project! Fun right!?
            These days I've worked myself into a habbit of using engines to write the games I work on (<a
                href="http://lilrooness.itch.io/control">see recent project here</a>) but recently I've been feeling a
            bit dissalusioned with them. While they try to be helpful and provide the best abstractions they can,
            sometimes I think no abstraction is better than a one size fits all code moster that forces you to build
            software in unnatural ways? I mean the whole Entity/Component thing works fine when you need to support
            every possible game developer's vision of what they want to create, but when you have something specific in
            mind, do you really need it?<br /><br />

            Also It's been making me feel a little insecure about my abilities as a
            programmer. Do I really need these engines as a crutch to create the things I want to make?. SO! It's
            time to get back to basics.<br /><br />

            I want to make a card game.<br />
            At a very basic level, this means that I want 2D sprites that I can move
            around
            the screen. There will be a spritesheet that I will want to import and pass to the graphics card, and
            there are going to be a lot aniamtions happening EG chaning colour/position/scale/UVcoords etc
            ...<br /><br />

            I'm choosing OpenGL for the graphics (I want the ability to program neat hardware accelarated effects and
            stuff) and SDL2 for handling cross platform widow creation/ input / sound and
            other game related platform dependent stuff that would otherwise be bit of a pain.<br /><br />

            First of all a note on the style of C++ I'm going to be writing, as the lack of OOP here might scare and
            confuse people a bit.<br /><br />

            The way I like ot start building out a game project is to have everything global. I might have one game
            struct that I pass around to every function, but the effect is the same. The thing is, we dont know what
            we're building yet, so we don't want to add abstractions that we think are sensible now, but that we will
            have to spend time ripping out later on when we figure out they aren't what we need. After all <a
                href="https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction?utm_content=buffer3d2a9&utm_medium=social&utm_source=facebook.com&utm_campaign=buffer&fbclid=IwAR2RcS9CofU6A_pbMj0LRznHiF0NHK0OYxkIoCUUnI8ITKtesHWkHUwKGjk">
                no abstraction is better than the wrong abstraction</a><br /><br />
            Also, I'm not te biggest fan of classes, I prefer to use structs when I can, besides, we don't really have
            much use for the C++ RAII stuff here anyway, since (and as you will see) I will tend not to have to release
            memory that I allocate as we can just reuse it later, and there are very few other resources that we have
            to care about releasing/destroying besides our one texture, and a few shader files.

            Another supposed benefit of using classes is class hierarchies. I'm not a fan of this either for games, as
            in C++, when you refer to an object in an abstract way, you have to use a pointer. So if you want an array
            of abstract "Entities" each element in that array will have to be a pointer to random location on the heap,
            which really wont have very nice cache behaviour if all we want to do is loop through them.

        <pre>
            //Entity is some abstract class
            std::vector&lt;Entity*&gt; enties;

            //Not great cache behaviour
            for(Entity *e : entities) {
                e-&gt;x ++;
                e-&gt;y ++;
            }
        </pre>

        Struct's however (or objects of flat classes for that matter) can just be allocated "as is" and if you want to
        have an array of them, they will be layed out in memory as you would expect them to be, one after the other.
        Meaning that we can let our CPU help us out with stuff like predictive caching and other nice
        goodness.<br /><br />

        Also, the way we are going to want to lay things out in memory requires us to be a little "flexible" with our
        abstractions too. OpenGL is an API with which you can talk to your graphics card. OpenGL wants to recieve data
        (vertecies, textures, matriceis) in Buffers that we map from RAM to VRAM, so we are going to want to do things
        like, store vertecies for things we want to render at the same time, together in one buffer.<br></br>

        Anyway enough talk, lets get to some code, I'm largely going to emit the OpenGL specific code here as its really
        not what this post is about, if you want to learn about it I recommend (https://learnopengl.com/) most of the
        begginer stuff there is pretty good (if a little out of date, but itl get ya goin).

        Lets setup something for sprite rendering.
        I want to be able to do something like this:

        <pre>
            render(cardSpriteMaterial, cardData);
            render(candleSpriteMaterial, candleData);
            render(smokeSpriteMaterial, smokeData);
        </pre>

        So lets build towards that:

        <pre>
            struct SpriteMaterial {
                // just some ID
                uint id; 

                // this is an thing that identifies to OpenGL a bunch of parameters that we setup somewhere else 
                uint BufferHandle_VAO; 
                // vertecies and UV coords of the sprites "model data" which is just points that make up a square
                uint BufferHandle_vertexAndUVData;
                // the draw order for the vertecies
                uint BufferHandle_indexData; 

                // location offsetdata
                uint BufferHandle_vertexOffsetData; 
                // offsets for the sprites position in the texture map
                uint BufferHandle_textureOffsetData; 
                
                // something we can multiply the texture colour by if we want to change that
                uint BufferHandleInstanced_tintData; 
                // we can use this to alter the scale of the things we draw
                uint BufferHandleInstanced_scaleData; 

                // id of the shader program we want to use when drawing
                uint shaderProgramID;
            }
        </pre>

        <span class="snippet">uint
            BufferHandle_...</span> fields are just handles to areas of VRAM.<br /><br />

        Most engines, even the very high level ones, allow you to animate stuff like color, scale and position and I
        want to be able to quickly fire off animations for stuff like that, which is why I've added the handles to the
        tint and scale buffers here. The more stuff we can expose at this point the better of we're going to be later
        but speaking from experience, this this a pretty reasonable abstraction.<br /><br />

        If that wasn't really clear dont worry. I shall explain after this bit ...<br /><br />

        lets make the struct that will hold the actual data referred to by those <span class="snippet">uint
            BufferHandle_...</span>
        variables

        <pre>
            struct SpriteClass {
                SpriteMaterial material;
            
                std::vector&lt;GLfloat&gt; Buffer_vertexOffsetData;
                std::vector&lt;GLfloat&gt; Buffer_textureOffsetData;
                std::vector&lt;GLfloat&gt; Buffer_tintValueData;
                std::vector&lt;GLfloat&gt; Buffer_scaleValueData;
            
                bool BufferRefreshFlag_vertexOffsetData;
                bool BufferRefreshFlag_textureOffsetData;
                bool BufferRefreshFlag_tintValueData;
                bool BufferRefreshFlag_scaleValueData;
            
                std::vector&lt;SpriteAnimation&gt; scaleAnimations;
            
                float defaultScale{ 1.0f };
            };
            
        </pre>

        <!-- <pre>template&lt;typename T&gt;</pre> -->
        </p>
    </div>

</body>

</html>